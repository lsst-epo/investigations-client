# Next frontend

Next.js frontend intended to be used with the Rubin EPO [craft-cms-template](https://github.com/lsst-epo/craft-cms-template/).

## Local development

0. Ensure that the Craft CMS container is running and functioning correctly by going to http://localhost:8080/api, if everything is working fine you should see some message about a missing GraphQL query
1. Create a `.env` file in the root of your project based on the `.env.local.sample`
1. Install dependencies `yarn`
1. Start the dev server `yarn dev`

## Components

Changed from previous iterations of the template, many atomic components have been removed from this repository in favor of using the [@rubin-epo/epo-react-lib](https://github.com/lsst-epo/epo-react-lib/tree/main/packages/epo-react-lib) package.

### Styling

Global styles are also imported from this library, although some of the resets and other basic styling have been preserved as SASS inside of this template.

The `@rubin-epo/epo-react-lib/styles` styles are added to the application in `[locales]/layout` using `styled-components` [global styles helper](https://styled-components.com/docs/api#createglobalstyle) and wrapped in a `'use client'` directive. A pre-release build of the EPO React libraries is necessary for this to function.

To work correctly in the app directory, a styles registry consumes the CSS generated by `styled-components`, for understanding on how this works see [this issue](https://github.com/styled-components/styled-components/issues/3856)

Following that, `styles.scss` is imported in the same page.

```tsx
import { GlobalStyles } from "@rubin-epo/epo-react-lib/styles"; // styled-components
import styles from "@/styles/styles.scss"; // SASS stuff

const RootLayout = async ({ params: { locale = fallbackLng }, children }) => {
  return (
    <html lang={locale}>
      <head></head> // empty header tag is necessary for styles
      <body>
        <UIDReset>
          <StyledComponentsRegistry>
            <GlobalStyles includeFonts={false} />
            <GlobalDataProvider>{children}</GlobalDataProvider>
          </StyledComponentsRegistry>
        </UIDReset>
      </body>
    </html>
  );
};
```

Components can be imported and used across the application.

```tsx
import { Container } from "@rubin-epo/epo-react-lib";

export default function Component() {
  return <Container />;
}
```

## Localization

This application is localized using a combination of i18next, Next.js, and CraftCMS. The following outlines the role each piece plays:

### Next.js

At the top level of the app directory is a `[locale]` wildcard folder which will match the first URI segment to determine the locale.

The default locale's key is not shown in the URI, this function along with other locale detection and routing is managed by the `next-intl` package's [middleware](https://next-intl-docs.vercel.app/docs/next-13/middleware).

Example:

```
/ <-- English homepage

/es <-- Spanish homepage

/surveying-the-solar-system <-- English investigation landing page

/es/surveying-the-solar-system <-- Spanish investigation landing page
```

The locale URI segment is considered the source of truth for locale in this application.

### i18next

i18next is set up to work for both server and client components in the app directory. The language config is defined in `lib/i18n/settings`.

There are separate `useTranslation` hooks for client and server components. `lib/i18n` should be used for server, and `lib/i18n/client` for client components.

### CraftCMS

All CMS content is localized using CraftCMS. Craft has separate sites defined for each locale that can be accessed during editing. In GraphQL queries, `site` is the parameter passed to Craft that will determine which locale to retrieve. For the default locale, the site is named `default` and for other locales it uses the two digit locale identifier.

```typescript
export async function getEntryDataByUri(uri, site = "default", previewToken) {
  const query = gql`
    ${homepageFragment}
    ${pageFragment}
    ${allPageBlocksFragment}
      {
        entry (site: "${site}", uri: "${uri}") {
          ...homepageFragment
          ...pageFragment
        }
      }
    `;
  const data = await queryAPI({ query, previewToken });
  return data.entry;
}

getEntryDataByUri("__home__"); // will retrieve the English homepage content
getEntryDataByUri("__home__", "es"); // will retrieve the Spanish homepage content
```

## Running the client within a Docker container

Running the client within a container is a good way to test deployment in a production-like environment.

There is one crucial thing to keep in mind when configuring your local client to run in a Docker container: Docker containers run in an isolated network that have a different concept of the usage of "localhost". As such, despite the fact that the Craft CMS container may be exposed at localhost on port 8080 on the host machine (your laptop), within the client container "localhost" is local to that container. In order for the client container to be able to communicate with the Craft CMS container you need to know the Craft CMS container's gateway IP address.

Luckily, a node.js script is bundled with this code and Docker allows for arguments to be passed into a `docker build` command.

In order to build the Docker client image **ensure the API project is running** then enter the following command in the root project folder:

```

docker build -t epo/rubin_ui . --build-arg API_IP=$(node getApiGatewayURL) --build-arg API_PORT=8080

```

As mentioned, if the Craft CMS container project is not running within a Docker container before running the above command then the build may succeed, but will have broken links, images, and missing content.

Finally, once the image is built, create/start the Docker container with the following command:

```

docker run -p 3000:3000 epo/rubin_ui

```

## Finding the Craft CMS container's IP address

### Automated:

For your convenience, a node.js script has been included in this repo that grabs the Craft CMS container Docker gateway IP and logs it to the terminal. Ensure the Craft CMS container is running, then in the terminal enter:

```

node getApiGatewayURL

```

### Manual:

1. Ensure that the Craft CMS container is running and functioning correctly by going to http://localhost:8080/api, if everything is working fine you should see some message about a missing GraphQL query
2. In the terminal, enter the command `docker network ls` and you should she text table output - under the "NAME" column verify that you see one row with the value of the Craft CMS container
3. Enter the command `docker network inspect <NAME>`
4. The ouput from the above command will be a JSON object, the gateway IP can be found at: IPAM.Config.Gateway

This IP will change between bringing up and down the container, so keep in mind that you'll need to do this step everytime you bring the Craft CMS containers down and back up.

```

```
